# A simplified re-implementation of core functions of the cTWAS framework that
#   are needed by FAMR-Susie

#' Update posterior parameters after running Susie-RSS
#' 
#' @description
#' Given Susie-RSS results, updates the PIP (alpha) and posterior mean (post_mu)
#' and posterior variance (tau2) of each variable in each "class" (SNPs and
#' exposures/factors). Part of the cTWAS Expectation-Maximization (EM) algorithm
#' to fit class-specific prior parameters for Susie-RSS.
#' 
#' @param res Susie-RSS results object generated by run_susie_with_priors; see
#' the susieR documentation for more details. Most relevantly for this function,
#' it contains the following elements:
#' 
#' \item{pip}{A numeric vector of Posterior Inclusion Probabilities (PIPs) 
#' for each variable}
#' 
#' \item{mu}{A numeric matrix of posterior mean estimates for each variable in
#' each credible set, with one row per credible set and one column per variable}
#' 
#' \item{mu2}{Similar to mu, but for posterior second moments}
#' 
#' \item{alpha}{A numeric matrix of PIPs for each credible set, with one row per 
#' credible set and one column per variable}
#' 
#' @param n_vars A list object giving the number of variables in each class, 
#' e.g. ('SNPs' = 10000, 'exposures' = 30)
#' 
#' @returns A list object with the following elements:
#' 
#' \item{alpha}{A list object with elements for each class of variables,
#' containing a numeric vector of PIPs for the variables of that class}
#' 
#' \item{tau2}{A list object with elements for each class of variables,
#' containing a numeric vector of posterior second moments (conditioned on the
#' variable having an effect) for the variables of that class}
#' 
#' \item{post_mu}{A list object with elements for each class of variables,
#' containing a numeric vector of posterior mean effect size estimates for
#' the variables of that class}
#' 
update_alpha_tau2 = function(res, n_vars) {
  alpha = list()
  tau2 = list()
  post_mu = list()
  pips = as.numeric(res$pip)
  mu2 = as.numeric(colSums(res$mu2))
  post_means = as.numeric(colSums(res$alpha * res$mu))
  pips = sapply(pips, function(x) max(x, 1e-10))  # prevent underflow issues
  mu2 = sapply(mu2, function(x) max(x, 1e-10))
  post_means = sapply(post_means, function(x) max(x, 1e-10))
  prev = 1
  # split the vectors into the parts corresponding to each class of variables
  for(k in names(n_vars)) {
    end = prev + n_vars[[k]] - 1
    alpha[[k]] = pips[prev:end]
    tau2[[k]] = mu2[prev:end]
    post_mu[[k]] = post_means[prev:end]
    prev = end + 1
  }
  return(list('alpha' = alpha, 'tau2' = tau2, 'post_mu' = post_mu))
}


#' Update cTWAS priors
#' 
#' @description
#' Given updated posterior parameters learned from running Susie-RSS given the
#' previous cTWAS priors, update the cTWAS prior inclusion probability and
#' prior variance for each class of variables (i.e. SNPs and exposures/factors). 
#' Part of the cTWAS EM algorithm.
#' 
#' @param alpha A list object with elements for each class of variables,
#' containing a numeric vector of PIPs for the variables of that class.
#' Usually generated by update_alpha_tau2.
#' 
#' @param tau2 A list object with elements for each class of variables,
#' containing a numeric vector of posterior second moments (conditioned on the
#' variable having an effect) for the variables of that class.
#' Usually generated by update_alpha_tau2.
#' 
#' @returns A list object with the following elements:
#' 
#' \item{pi}{A list containing the updated cTWAS prior inclusion probability
#' (prior probability of effect on the trait) for each class of variables}
#' 
#' \item{sigma2}{A list containing the updated cTWAS prior effect variances,
#' conditioned on the variable having an effect, for each class of variables}
#' 
update_pi_sigma2 = function(alpha, tau2) {
  new_pi = list()
  new_sigma2 = list()
  for(k in names(alpha)) {
    ak = alpha[[k]]  # pips in class k
    sum_ak = sum(alpha[[k]])
    new_pi[[k]] = sum_ak / length(ak)
    new_sigma2[[k]] = sum(ak * tau2[[k]]) / sum_ak
  }
  return(list('pi' = new_pi, 'sigma2' = new_sigma2))
}


# run susie given prior parameters and return results
#' Run Susie-RSS with cTWAS-inferred priors
#' 
#' @description
#' A wrapper function to run Susie-RSS with priors for each variable given by 
#' the cTWAS algorithm at its current EM iteration.
#' 
#' @param zscores A numeric vector of z-score association statistics for the 
#' variables on the trait of interest.
#' 
#' @param R A numeric matrix or sparse Matrix object of correlations between 
#' variables
#' 
#' @param prior_pi A list containing the updated cTWAS prior inclusion 
#' probability (prior probability of effect on the trait) for each class of 
#' variables (SNPs or exposures/factors)
#' 
#' @param prior_sigma2 A list containing the updated cTWAS prior effect 
#' variances, conditioned on the variable having an effect, for each class of v
#' ariables (SNPs or exposures/factors)
#' 
#' @param L The maximum number of effects (credible sets) Susie-RSS is allowed
#' to fit.
#' 
#' @returns A Susie-RSS results object. See the susieR documentation for more
#' details.
#' 
run_susie_with_priors = function(zscores, R, prior_pi=c(), prior_sigma2=c(), 
                                 L=10) {
  prior_pi_plain = as.numeric(unlist(prior_pi))
  prior_sigma2_plain = as.numeric(unlist(prior_sigma2))
  # prevent underflow issues
  prior_pi_plain = sapply(prior_pi_plain, function(x) max(x, 1e-10))
  prior_sigma2_plain = sapply(prior_sigma2_plain, function(x) max(x, 1e-10))
  prior_sigma2_plain = matrix(rep(prior_sigma2_plain, each = L), nrow=L)
  nw = max(0, 1 - sum(prior_pi_plain))  # null weight
  prior_pi_plain = prior_pi_plain / (1 - nw)

  # run susie
  z_plain = as.numeric(unlist(zscores))
  res = susie_rss(z_plain, R, L=L, # n=n,
                        prior_weights = prior_pi_plain,
                        prior_variance = prior_sigma2_plain,
                        null_weight = nw,
                        estimate_prior_variance=F)
  return(res)
}


#' cTWAS EM algorithm to optimize priors
#' 
#' @description
#' Implements the cTWAS Expectation-Maximization (EM) algorithm for fitting
#' prior probabilities and variances for variables of each "class" (SNPs and
#' exposures/factors). Each iteration runs Susie-RSS with the current priors,
#' then updates the priors given the Susie-RSS results.
#' 
#' @param zscores A numeric vector of z-score association statistics for the 
#' variables on the trait of interest.
#' 
#' @param R A numeric matrix or sparse Matrix object of correlations between 
#' variables
#' 
#' @param L The maximum number of effects (credible sets) Susie-RSS is allowed
#' to fit.
#' 
#' @param n_iter Number of EM iterations to run.
#' 
#' @returns A list object with the following elements:
#' 
#' \item{pi}{A list containing the updated cTWAS prior inclusion probability
#' (prior probability of effect on the trait) for each class of variables}
#' 
#' \item{sigma2}{A list containing the updated cTWAS prior effect variances,
#' conditioned on the variable having an effect, for each class of variables}
#' 
#' \item{n_vars}{A list object giving the number of variables in each class, 
#' e.g. ('SNPs' = 10000, 'exposures' = 30)}
#' 
estimate_priors_EM = function(zscores, R, L=1, n_iter=30) {
  # initialize priors
  prior_pi = list()
  prior_sigma2 = list()
  n_vars = list()
  
  # initialize priors
  M = dim(R)[1]  # total number of vars
  for(k in names(zscores)) {
    m_k = length(zscores[[k]])
    prior_pi[[k]] = rep(1 / M, m_k)  # uniform prior over the category
    prior_sigma2[[k]] = rep(50, m_k)  # reasonable starting value
    n_vars[[k]] = m_k
  }

  for(iter in 1:n_iter) {
    # iteratively run susie with current priors, update per-variable params
    #   (alpha and tau2), and update group priors (pi and sigma2)
    message('Running prior estimation iteration ', iter)
    res = run_susie_with_priors(zscores, R, prior_pi=prior_pi, 
                                prior_sigma2=prior_sigma2, L=L)
    new_params = update_alpha_tau2(res, n_vars)
    new_group_priors = update_pi_sigma2(new_params$alpha, new_params$tau2)
    for(k in names(new_group_priors$pi)) {
      prior_pi[[k]] = rep(new_group_priors$pi[[k]], n_vars[[k]])
    }
    for(k in names(new_group_priors$pi)) {
      prior_sigma2[[k]] = rep(new_group_priors$sigma2[[k]], n_vars[[k]])
    }
    message('Current pi:')
    message(new_group_priors$pi)
    message('Current sigma2:')
    message(new_group_priors$sigma2)
  }
  
  # allow equal priors between all variables if n_iter=0
  if(n_iter == 0) {
    for(k in names(prior_pi)) {
      prior_pi[[k]] = prior_pi[[k]] * 0 + 1
      prior_sigma2[[k]] = prior_sigma2[[k]] * 0 + 50
    }
  }
  return(list('pi' = prior_pi, 'sigma2' = prior_sigma2, 'n_vars' = n_vars))
}


#' Run final Susie-RSS regression and return results
#' 
#' @description
#' Runs Susie-RSS given prior inclusion probabilities and prior variances for 
#' each class of variables, and returns a comprehensive results object.
#' Intended to be used after the cTWAS prior-fitting EM algorithm has been run.
#' 
#' @param zscores A numeric vector of z-score association statistics for the 
#' variables on the trait of interest.
#' 
#' @param R A numeric matrix or sparse Matrix object of correlations between 
#' variables
#' 
#' @param priors A list object with the following elements:
#' 
#' \item{pi}{A list containing the updated cTWAS prior inclusion probability
#' (prior probability of effect on the trait) for each class of variables}
#' 
#' \item{sigma2}{A list containing the updated cTWAS prior effect variances,
#' conditioned on the variable having an effect, for each class of variables}
#' 
#' \item{n_vars}{A list object giving the number of variables in each class, 
#' e.g. ('SNPs' = 10000, 'exposures' = 30)}
#' 
#' @param L The maximum number of effects (credible sets) Susie-RSS is allowed
#' to fit.
#' 
#' @returns A list object with the following elements:
#' 
#' \item{pips}{A list object with elements for each class of variables,
#' containing a numeric vector of PIPs for the variables of that class}
#' 
#' \item{posterior_var}{A list object with elements for each class of variables,
#' containing a numeric vector of posterior second moments (conditioned on the
#' variable having an effect) for the variables of that class}
#' 
#' \item{posterior_mean}{A list object with elements for each class of 
#' variables, containing a numeric vector of posterior mean effect size 
#' estimates for the variables of that class}
#' 
#' \item{susieres}{A Susie-RSS results object returned by run_susie_with_priors;
#' see the susieR documentation for more details.}
#' 
#' \item{zscores}{Equal to the zscores parameter given as input.}
#' 
#' \item{R}{Equal to the R parameter given as input.}
#' 
#' \item{L}{Equal to the L parameter given as input.}
#' 
#' \item{sorted_pips}{DEPRECATED. The unlisted (vector-format) pips sorted
#' in decreasing order.}
#' 
get_results = function(zscores, R, priors=c(), L=10) {
  susieres = run_susie_with_priors(zscores, R, prior_pi=priors$pi, 
                                   prior_sigma2=priors$sigma2, L=L)
  res_df = list('pips' = list(), 'posterior_var' = list(), 
                'posterior_mean' = list(), susieres=susieres, zscores=zscores,
                R=R, priors=priors, L=L)
  
  # update and store final learned parameters
  final_params  = update_alpha_tau2(susieres, priors$n_vars)
  for(k in names(final_params$alpha)) {
    res_df$pips[[k]] = final_params$alpha[[k]]
    res_df$posterior_var[[k]] = final_params$tau2[[k]]
    res_df$posterior_mean[[k]] = final_params$post_mu[[k]]
    # retain variable names
    varnames = names(zscores[[k]])
    names(res_df$pips[[k]]) = varnames
    names(res_df$posterior_var[[k]]) = varnames
    names(res_df$posterior_mean[[k]]) = varnames
  }
  res_df$sorted_pips = sort(unlist(res_df$pips), decreasing=T)
  return(res_df)
}
